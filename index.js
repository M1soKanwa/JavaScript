// Навигация по DOM

/*

const htmlElement = document.documentElement
const headElement = document.head
const bodyElement = document.body
console.log(htmlElement);    // Выводя этот клг, мы получаем дерево HTML.
console.log(headElement);    // Выводя этот клг, мы получаем структуру HEAD.
console.log(bodyElement);    // Выводя этот клг, мы получаем структуру BODY.


// Поиск произвольного элемента

// --->>> elem.querySelectorALL(CSS);

Самый универсальный метод поиска,он возвращает 
все элементы внутри elem,удовлетворяющие данному CSS - селектору.

Этот метод действительно мощный,
потому что можно использовать любой CSS - селектор.
//

// --->>> Поиск по селектору класса

const elemsOne = document.querySelectorALL('.lesson__list');     // Обязательно указать точку *.*    // В скобках пишем название класса
console.log(elemsOne);

// --->>> Поиск по селектору тега

const elemsTwo = document.querySelectorALL('li');      // Вместо имени класса пишем, тег 
console.log(elemsTwo);

// --->>> Поиск по смешшаному селектору тега и класса

const elemsThree = document.querySelectorALL('li.lesson__item-list');
console.log(elemsThree);

// --->>> Поиск по тегу первого уровня вложенности 

const elemsFour = document.querySelectorALL('.lesson__list>li');
console.log(elemsFour);

// --->>> Поиск по нескольким классам 
const elemsFive = document.querySelectorALL('.lesson__list, .lesson__text');
console.log(elemsFive);

// --->>> Поиск по по вложенным классам 

const elemsSix = document.querySelectorALL('.lesson__list .lesson__text');
console.log(elemsSix);

// --->>> Поиск по ID

const elemsSeven = document.querySelectorALL('#listItem');
console.log(elemsSeven);

// --->>> Поиск по атрибуту

const elemsEight = document.querySelectorALL('[data-item]');
console.log(elemsEight);

// --->>> Поиск по атрибуту со значением 

const elemsNine = document.querySelectorALL('[data-item="85"]');
console.log(elemsNine);



//// --->>> Также есть querySelector - который находит и выводит первый попавшийся элемент.

//// --->>> getElementById - поиск введется только в *document*,поэтому нужно писать : 

const elem = document.getElementById('listItem');
console.log(elem);

//// --->>> Существует еще одна похожая команда :
getElementsByTag - ищет элементы с данным тегом и возвращает их коллекцию. Передав *+* вместо тега, можно получить всех потомков.

const elems = document.getElementsByTag('li');
console.log(elems);


//// --->>> getElementsByClassName - суть такая же как и предыдущие команды.Возвращает элементы,которые имеют данный CSS класс.

const elems = document.getElementsByClassName('lesson__item-list');
console.log(elems);

//// --->>> getElementByName -  используется очень редко.Возвращает элементы с 
заданным атрибутом name.ПОИСК ТОЛЬКО ВНУТРИ document

const elems = document.getElementByName('list');
console.log(elems);

//// --->>> Чаще всего используется метод querySelectorALL.


////      Метод поиска                Ищет по                Возвращает...           Ищет внутри элемента?           Живая коллекция?
         
        querySelector             Любой CSS-селектор        Один объект               ДА                                 НЕТ
        
        querySelectorALL           Любой CSS-селектор      коллекцию объектов          ДА                                 НЕТ
        
        getElementById                   ID                  Один объект               НЕТ                                НЕТ
        
        getElementsByTagName          тег или *            коллекцию объектов          ДА                                 ДА
        
        getElementsByClassName       имя класса            коллекцию объектов          ДА                                 ДА
        
        getElementByName               name                коллекцию объектов          НЕТ                                ДА





//// --->>> closest 

Метод elem.closest(css) - ищет ближайщего предка,
который соответсвует CSS - селектору.Сам элемент
также включается в поиск.

Предки элемента это родитель,родитель родителя,
его родитель и так далее.Вместе они образуют цепочку 
иерархии от элемента до вершины.

Другими словами, метод closest поднимается вверх от 
элемента и проверяет каждого из родителей.Если он 
соответсвует селектору,поиск прекращается. Метод возвращает
либо предка,либо null, если такой элемент не найден.

Свойство parentElement - возвращает только 
непосредственного родителя элемента.

-->>
const elem = document.querySelector('.lesson__item-sub-list');
const parentList = elem.closest('.lesson__list');
console.log(parentList);
-->>

Очень полезный метод, часто используемый для проверки
на существование того или иного родителя,либо для изменения
родителя конкретного элемента.


//// --->>> matches

Ничего не ищет, а проверяет, удовлетворяет ли 
элемент CSS-селектору, и возвращает true или false.

const elems = document.querySelectorALL('.lesson__item-list');
for (let elem of elems) {
    if (elem.matches('[class$="lesson__item-list_red"]')) {
        console.log('Красный');
    } else if (elem.matches('[class$="lesson__item-list_blue"]')) {
        console.log('Синий');
    }
}


//// --->>> Добавлено : 
Получив объект тем или иным способом мы можем 
применять свойства навигации о которых написано выше.

const text = document.querySelector('.lesson__text');
const list = text.nextElementSibling;
console.log(list);


////                                          Изменение документа DOM                                                         ////



//// --->>> Содержимое элемента innerHTML          <<<--- \\\\

//// --->>> Получаем объект



const textElement = document.querySelector('.lesson__text');



//// --->>> Получаем Содержимое объекта *как есть* вместе с HTML



const textElementContent = textElement.innerHTML;
console.log(textElementContent);



//// --->>> Перезаписываем Содержимое объекта



textElement.innerHTML = 'Abracadabra';



//// --->>> Дописываем Содержимое объекта 



textElement.innerHTML = 
`<p>${textElementContent}</p> <p> Abracadabra </p>`;

console.log(textElement.innerHTML);




//// --->>> Содержимое элемента целиком outerHTML        <<<--- \\\\


//// --->>> Получаем объект



const textElement = document.querySelector('.lesson__text');



//// --->>> Получаем Содержимое объект *как есть*
//// --->>> вместе с HTML,а также сам элемент



const textElementContent = textElement.outerHTML;
console.log(textElementContent);


//// --->>>  Создание элементов:  <<<--- \\\\

Можно создавать новые элементы DOM с помощью метода createElement.


После создания вы можете добавить эти элементы в документ с помощью методов appendChild, insertBefore и т. д.
Удаление элементов:


Элементы можно удалить из дерева DOM с помощью метода removeChild.
Изменение атрибутов элемента:


Можно изменять атрибуты элемента с помощью методов setAttribute, removeAttribute, getAttribute и т. д. 



//// --->>> Обработка событий:

Добавление обработчиков событий:

Вы можете присоединять обработчики событий к элементам DOM с помощью методов addEventListener.
Обработчики событий могут реагировать на пользовательские взаимодействия, такие как щелчки, нажатия клавиш, движения мыши и т. д.
Объект события:


При возникновении события создается объект события, содержащий информацию о событии.
Свойства объекта события предоставляют детали, такие как тип события, целевой элемент, координаты мыши и т. д.
Манипулирование документом:
Изменение структуры документа:


JavaScript может динамически изменять структуру документа путем добавления, удаления или модификации элементов.
Это позволяет динамически генерировать содержимое и изменять пользовательский интерфейс.
Стилизация документа:


JavaScript может изменять CSS-стили для изменения внешнего вида элементов динамически.
Это включает в себя свойства, такие как цвет, размер, положение, видимость и т. д.
Совместимость между браузерами:
Совместимость браузеров:


Хотя DOM является стандартом, различные браузеры могут реализовывать его немного по-разному.
Совместимость между браузерами можно обеспечить, написав код, который соответствует стандартам DOM,
 и используя обнаружение возможностей и полифиллы там,где это необходимо.


Различия в обработке событий:
Обработка событий может различаться между браузерами, особенно в старых версиях.
Использование библиотеки jQuery или современных фреймворков, таких как React, может помочь абстрагироваться от этих различий.
Производительность:
Производительность манипуляций DOM:


Частые манипуляции DOM могут сказываться на производительности, особенно на мобильных устройствах и старых браузерах.
Минимизация манипуляций DOM путем объединения изменений или использования техник, таких как виртуальный DOM, может улучшить производительность.
Делегирование событий:


Делегирование событий может улучшить производительность, присоединяя обработчики событий к родительским элементам вместо отдельных дочерних элементов.
Это уменьшает количество обработчиков событий и повышает эффективность, особенно для динамически создаваемого контента.
Это подробный обзор JavaScript DOM. Понимание его концепций и методов важно для создания динамических и интерактивных веб-приложений.





getElementById:

Значение: Возвращает элемент по его уникальному идентификатору (ID).
getElementsByClassName:

Значение: Возвращает коллекцию элементов, которые имеют заданный класс.
getElementsByTagName:

Значение: Возвращает коллекцию элементов с заданным тегом.
querySelector:

Значение: Возвращает первый элемент в документе, который соответствует указанному селектору CSS.
querySelectorAll:

Значение: Возвращает все элементы в документе, которые соответствуют указанному селектору CSS.
createElement:

Значение: Создает новый элемент с указанным тегом.
appendChild:

Значение: Добавляет новый дочерний элемент в конец списка дочерних элементов родительского элемента.
insertBefore:

Значение: Вставляет новый дочерний элемент перед существующим дочерним элементом в списке дочерних элементов родительского элемента.
removeChild:

Значение: Удаляет указанный дочерний элемент из списка дочерних элементов родительского элемента.
setAttribute:

Значение: Устанавливает значение указанного атрибута для элемента.
removeAttribute:

Значение: Удаляет указанный атрибут из элемента.

getAttribute:

Значение: Возвращает значение указанного атрибута элемента.

addEventListener:

Значение: Присоединяет обработчик события к элементу.

removeEventListener:

Значение: Удаляет обработчик события из элемента.

innerHTML:

Значение: Получает или устанавливает HTML-содержимое элемента.

textContent:

Значение: Получает или устанавливает текстовое содержимое элемента.

style:

Значение: Получает объект, представляющий стили элемента, которые можно изменять.








 


*/